import { DynamicModule, DynamicModuleStatus } from "./DynamicModule";

import { IdentifierSplit } from "transformice.js";
import { Client, Identifier, enums } from "transformice.js";

import zlib from "zlib";
import { EventEmitter } from "events";
import EventRegistry from "./EventRegistry";

var client = new Client("", "")
var a = new EventRegistry();
a.on(client, "roomPlayerDie",)

class Bt800Heart implements DynamicModule {
    private trackedDynEes: {
        ee: EventEmitter,
        eventName: string | symbol,
        listener: (...args: any[]) => void)
    }[] = [];

    /**
     * Tracks a dynamic event emitter listener that will be cleared on unload.
     */
    private trackDynamicEe(
        ee: EventEmitter, eventName: string | symbol,
        listener: (...args: any[]) => void
    ) {
        this.trackedDynEes.push({ ee: ee, eventName: eventName, listener: listener });
    }

    load() {
        var evt: string;
        var cb;

        client.on<"roomMessage">("roomMessage", (a) => {})
        client.on(evt = "roomMessage", cb = (message) => {
            if (client.name === message.author.name) return;
            if (message.content.match("allplank"))
                client.sendRoomMessage("retard");
            if (message.content.match("cat"))
                client.sendRoomMessage("woof");
            if (message.content.match("meow"))
                client.sendRoomMessage("moo");
            if (message.content.match("rini"))
                client.sendRoomMessage("scary as always");
            if (message.content.match(/\b(bt|buildtool)/mi))
                client.sendRoomMessage("bt rocks!");
            if (message.content.match("boss"))
                client.sendRoomMessage("boss lynn durand sp beside jiren camp");
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "ready", cb = () => {
            console.log("ready!");
            /*client.enterRoom("*#cbase bt", {
                password: "1020"
            });*/
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "rawPacket", cb = (conn, ccc, packet) => {
            packet.readPosition = 2;
            switch (ccc) {
                case Identifier(4, 3): {
                    //let objs = ShamanObject.fromPacket4_3(packet);
                    //console.dir(objs);
                    break;
                }
                case Identifier(5, 2): {
                    let map_code = packet.readInt();
                    let num_players = packet.readShort();
                    let round_code = packet.readByte();
                    let enclen = packet.readInt();

                    console.log("map_code", map_code);
                    console.log("# of players", num_players);
                    console.log("round number", round_code);

                    if (enclen > 0) {
                        let encxml = packet.readBufBytes(enclen);
                        console.log("length encxml:", encxml.length);
                        console.log(zlib.inflateSync(encxml).toString());
                    }

                    console.log("author", packet.readUTF());
                    console.log("perm", packet.readByte());
                    //console.log("? bool", packet.readBool());
                    break;
                }
            }
            //console.log("receive",IdentifierSplit(ccc))
            //console.log(packet.toString())
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "roomMessage", cb = (message) => {
            console.log(`[${message.author.name}] ${message.content}`);
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "roomChange", cb = (newRoom) => {
            //if (newRoom.name == "*#cbase bot bt") {
            //client.sendRoomMessage("!pw abc");
            client.sendRoomMessage("hi ! ðŸ˜€");
            //}
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "connect", cb = (conn) => {
            console.log("establish conn", conn.socket.remoteAddress, conn.socket.remotePort);
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "restart", cb = () => {
            console.log("restarting!");
            console.trace();
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "loginError", cb = (code, err1, err2) => {
            // code
            // 1: already connected
            // 2: incorrect
            console.error("Login err", code, err1, err2);
        });
        this.trackDynamicEe(client, evt, cb);

        client.on(evt = "connectionError", cb = (err) => {
            console.error("Connection err", err);
        });
        this.trackDynamicEe(client, evt, cb);

        return DynamicModuleStatus.OK;
    }

    unload() {
        for (let i = 0; i < this.trackedDynEes.length; i++) {
            let dyn_ee = this.trackedDynEes[i];
            dyn_ee.ee.off(dyn_ee.eventName, dyn_ee.listener);
        }

        return DynamicModuleStatus.OK;
    }
}